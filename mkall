#!/usr/bin/perl -w

# $Id: mkall,v 1.6 1999/09/04 17:43:44 root Exp $

# Copyright (c) 1999 Mark Summerfield. All Rights Reserved.
# May be used/distributed under the GPL.


use strict ;

use Getopt::Long ;

use vars qw( $VERSION ) ;
$VERSION = '0.10' ;

my %Opt ;


# main

&getoptions ;

{
    my $time = time ;

    my $all  = ( -e $Opt{'output'} or -e "$Opt{'output'}.m" ) ? 
               $Opt{'output'} : 'all' ;

    unless( $Opt{'clear'} ) {
        foreach my $file ( <*.m> ) {
            my $newfile = $file ;
            $newfile =~ s/\.m$//o ;
            if( $Opt{'force'} or ( not -e $newfile ) or 
               ( (stat( $newfile ))[9] < (stat( $file ))[9] ) ) { 
                print STDERR "Expanding macros in $file to $newfile\n" 
                if $Opt{'verbose'} ;
                system "macro -C -f macro $file > $newfile\n"
            }
        }
    }

    if( ( not $Opt{'Clear'} ) and ( $Opt{'force'} or $Opt{'convert'} ) ) {
        eval {
            open ALL, $all or die "Failed to open $all: $!\n" ;

            while( <ALL> ) {
                my( $dst ) = /\@Include\s*\{?\s*"?([^"\s{}]+)/o ; #}
                next unless defined $dst ;
                next unless $dst =~ /\.lt$/o ;

                eval {
                    my $src = $dst ;
                    $src =~ s/\.lt$/.txt/o ; 
                    if( not -e $src ) {
                        ( $src = $dst ) =~ s/\.lt$/.pod/o ;
                        if( not -e $src ) {
                            ( $src = $dst ) =~ s/\.lt$/.html/o ;
                            if( not -e $src ) {
                                ( $src = $dst ) =~ s/\.lt$/.htm/o ;
                                if( ( not -e $src ) and ( not -e $dst ) ) {
                                    die "Failed to find source for $dst\n" ;
                                }
                                else {
                                    $src = undef ;
                                }
                            }
                        }
                    }

                    if( defined $src ) {
                        die "Skipping zero length source $src\n" if -z $src ;

                        my $filter ;
                        ( $filter ) = $src =~ /\.(\w+)$/o ;
                        $filter .= 'l' if $filter eq 'htm' ;
                        my $x = ( $Opt{'txt'} and $filter eq 'txt' ) ? 
                                $Opt{'txt'} : '' ;
                        if( $Opt{'force'} or
                           ( ( not -e $dst ) or 
                             (stat( $dst ))[9] < (stat( $src ))[9] ) ) {
                            print STDERR "Converting $src to $dst\n" 
                            if $Opt{'verbose'} ;
                            system "${filter}2lout $x -w 0 $src > $dst" 
                        }
                    }
                } ;
                warn $@ if $@ ;
            }
        } ;
        warn $@ if $@ ;
    }

    unlink <*.l[id]> if $Opt{'preclear'} ;


    my $error = $Opt{'error'} ? "-e $Opt{'error'}" : '' ;
    my $i = 0 ;

    if( not $Opt{'clear'} ) {
        my $I = defined $ENV{'LOUTINC'} ? "-I $ENV{'LOUTINC'}" : '' ;

        while( $Opt{'runs'}-- ) { 
            $i++, print STDERR "Lout pass $i" if $Opt{'verbose'} ;

            system "lout $I $error $Opt{'lout'} $all > $Opt{'output'}.ps" ; 

            print STDERR " - Errors remain" 
            if $error and ( not -z $error ) and $Opt{'verbose'} ;
            print STDERR "\n" if $Opt{'verbose'} ;
        }

        system "ps2pdf $Opt{'output'}.ps $Opt{'output'}.pdf &" if $Opt{'pdf'} ;
        if( $Opt{'zip'} ) {
            unlink "$Opt{'output'}.ps.gz" ;
            system "gzip -9 $Opt{'output'}.ps &" ;
        }
    }

    unlink <*.l[id]> if $Opt{'postclear'} or $Opt{'clear'} ;

    if( $Opt{'clear'} ) {
        foreach( <*.m> ) {
            s/\.m$//o ;
            unlink ;
        }
    }

    if( $Opt{'Clear'} ) {
        foreach( <*.lt> ) {
            my $file = $_ ;
            $file =~ s/\.lt$//o ;
            unlink if -e "$file.txt.m"  or -e "$file.pod.m" or 
                      -e "$file.html.m" or -e "$file.htm.m" ; 
        }
        unlink "$all.ps", "$all.ps.gz" ;
    }

    unlink $Opt{'error'} if $Opt{'clear'} or 
                            ( $Opt{'error'} ne 'STDERR' and 
                              $Opt{'postclear'} and 
                              -z $Opt{'error'} ) ; 
    
    if( $Opt{'verbose'} and not $Opt{'clear'} ) {
        $error = ( ( not -e $Opt{'error'} ) or ( -z $Opt{'error'} ) ) ? 
                    '' : " - Errors remain in $Opt{'error'}" ;
        $time = time - $time ;
        my( $s, $m, $h ) = (gmtime( $time ))[0..2] ;
        my $es = $i == 1 ? '' : 'es' ;
        printf STDERR "Lout's pass$es took %02d:%02d:%02d$error\n", $h, $m, $s ;
    }
}


# subroutines


sub getoptions {

    # Defaults.
    $Opt{'clear'}       = 0 ;
    $Opt{'Clear'}       = 0 ;
    $Opt{'convert'}     = 1 ;
    $Opt{'error'}       = 'lout.err' ;
    $Opt{'force'}       = 0 ;
    $Opt{'lout'}        = '-a' ;
    $Opt{'output'}      = 'all' ;
    $Opt{'pdf'}         = 0 ;
    $Opt{'preclear'}    = 1 ;
    $Opt{'postclear'}   = 1 ;
    $Opt{'runs'}        = 5 ;
    $Opt{'Runs'}        = 0 ;
    $Opt{'txt'}         = '-v 1 -H 1' ;
    $Opt{'verbose'}     = 1 ;
    $Opt{'zip'}         = 1 ;

    &help if defined $ARGV[0] and $ARGV[0] =~ /^(-h|--help)$/o ;

    Getopt::Long::config 'no_ignore_case' ;
    GetOptions( \%Opt,
        'clear',
        'Clear',
        'convert|t=i',
        'error|e=s',
        'force|f',
        'lout|l=s',
        'output|o=s', 
        'pdf|P',
        'preclear|c=i',
        'postclear|C=i',
        'runs|r=i', 
        'Runs|R=i',
        'source|s=s',
        'txt|x=s',
        'verbose|V=i',
        'zip|z=i',
        ) or &help ;

    $Opt{'error'} = '' if $Opt{'error'} =~ /^stderr$/oi ;

    if( $Opt{'Clear'} ) {
        $Opt{'clear'}     = 1 ;
        $Opt{'preclear'}  = 1 ;
        $Opt{'postclear'} = 1 ;
    }

    if( $Opt{'Runs'} ) {
        $Opt{'runs'}      = $Opt{'Runs'} ;
        $Opt{'preclear'}  = 0 ;
        $Opt{'postclear'} = 0 ;
    }
}


sub help {

    print STDERR <<__EOT__ ;

mkall v $VERSION. Copyright (c) Mark Summerfield 1999. All rights reserved.
May be used/distributed under the GPL.

usage: mkall [options] 

options: (use the short or long name followed by the parameter where req'd)
-c --preclear  b  Clear index files before runs [$Opt{'preclear'}]
-C --postclear b  Clear index files after runs [$Opt{'postclear'}]
   --clear        Clear index files and error file but don't run lout
   --Clear        Same as clear but also clear all intermediate files
-e --error     s  Error file or STDERR [$Opt{'error'}]
-f --force        Force conversion (see -t)
-h --help         Show this screen and exit
-l --lout      s  Lout options, e.g. "-U -s" ["$Opt{'lout'}"]
-o --output    s  Output filename (excl. suffix) [$Opt{'output'}]
-r --runs      i  Number of lout runs to perform [$Opt{'runs'}]
-R --Runs      i  Same as -r plus -c 0 and -C 0 [$Opt{'Runs'}]
-t --convert   b  Convert .pod, .txt and .html files to .lt [$Opt{'convert'}]
-P --pdf          Create .pdf file
-V --verbose   b  Verbose [$Opt{'verbose'}]
-x --txt       s  Options for txt2lout in addition to -w 0 ["$Opt{'txt'}"]
-z --zip       b  Convert .ps to .ps.gz [$Opt{'zip'}]

b = boolean 1 = true, 0 = false; i = integer; s = string e.g. filename
NB will call lout with -I \$LOUTINC for your local files

e.g. #1 (no options are actually required so usually): mkall
e.g. #2: mkall -e stderr -r 5 -P -l "-s -a"
__EOT__
    exit ;
}


=pod SCRIPT CATEGORIES

Lout

=pod DESCRIPTION

Simple `makefile' type wrapper for lout

=pod PREREQUISITES

Pragmas:

C<strict>

Modules:

C<Getopt::Long>
C<Macro>

=pod OSNAMES

Linux

=pod LICENSE

GPL.

=cut
